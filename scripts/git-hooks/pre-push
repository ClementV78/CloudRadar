#!/usr/bin/env bash
set -euo pipefail

# Local pre-push guard:
# Block push when commits being pushed modify src/** without updating VERSION.
# Bypass locally with: SKIP_VERSION_GUARD=1 git push

remote_name="${1:-origin}"

if [[ "${SKIP_VERSION_GUARD:-0}" == "1" ]]; then
  exit 0
fi

is_zero_sha() {
  [[ "$1" =~ ^0+$ ]]
}

while read -r local_ref local_sha remote_ref remote_sha; do
  # No update line (defensive)
  if [[ -z "${local_ref:-}" ]]; then
    continue
  fi

  # Branch/tag deletion
  if is_zero_sha "${local_sha}"; then
    continue
  fi

  src_changed=0
  version_changed=0

  if is_zero_sha "${remote_sha}"; then
    # New remote ref: consider commits that are not already known by the remote.
    # $1 may be a URL (git push https://...), not a configured remote name.
    rev_list_args=("${local_sha}" --not)
    if git remote | grep -qx "${remote_name}"; then
      rev_list_args+=("--remotes=${remote_name}")
    else
      rev_list_args+=(--remotes)
    fi
    mapfile -t commits < <(git rev-list "${rev_list_args[@]}")
  else
    mapfile -t commits < <(git rev-list "${remote_sha}..${local_sha}")
  fi

  for commit in "${commits[@]:-}"; do
    while read -r file; do
      [[ -z "${file}" ]] && continue
      [[ "${file}" == src/* ]] && src_changed=1
      [[ "${file}" == "VERSION" ]] && version_changed=1
    done < <(git diff-tree --no-commit-id --name-only -r "${commit}")
  done

  if [[ "${src_changed}" -eq 1 && "${version_changed}" -eq 0 ]]; then
    cat >&2 <<'EOF'
ERROR: Push blocked.
Detected changes under src/** without a VERSION update in pushed commits.

Fix:
  scripts/release/bump-app-version.sh
  # Then stage files modified by the bump script (check with: git status)
  git add VERSION <other files modified by bump-app-version.sh>
  git commit --amend --no-edit    # or create a follow-up commit

Temporary bypass (local only):
  SKIP_VERSION_GUARD=1 git push
EOF
    exit 1
  fi
done

exit 0
